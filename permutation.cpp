#include <bits/stdc++.h>
using namespace std;

/* 1. 순열이란? 

순서와 상관있게 뽑는다면? -> 순열

순서와 상관없이 뽑는다면? -> 조합

예시 : {1,2,3} 중 두 가지 숫자를 뽑으라고 한다면, 

조합의 경우 {1,2} {2,3} {1,3} 의 3가지의 경우의 수만을 가진다.

그러나, 순열의 경우엔 다음과 같다.

앞에 1이 오는경우 : {1,2}, {1,3}
앞에 2가 오는경우 : {2,1}, {2,3}
앞에 3이 오는경우 : {3,1}, {3,2}

이렇게 총 6개의 경우의 수를 가지게 된다는 것

만약 문제에서 ~~ 순서를 재배치하여~ ~ 한 순서의 경우라는 사족이 붙을 경우 순열이라고 생각하면 된다. (100% 는 아님)


2. next_permutation?

그렇다면 코드로 순열을 구현하는 방법은 무엇일까, 편리하게도 c++은 next_permutation 함수를 지원한다.

next_permutation()의 매개변수는 (첫번째 매개변수 : 시작 지점, 두번째 매개변수 : 끝 지점) 간단하게 from ~ to 로 설명할 수 있겠다.

만약 {1, 2, 3} 을 원소로 가지는 배열이 있다면, 해당 배열의 인덱스는 0, 1, 2가 될 것이다. 이것이 만약 array 형태라면

next_permutation(0, 3); 이라고 하면된다. 두번째 매개변수는 미만의 의미를 나타내기 때문

3. 구현
*/

int main() {
    int a[] = {1,2,3,4};
    
    sort(&a[0], &a[4]);

    do{
        for(int i : a) cout << i << " ";
        cout << '\n';
    }while(next_permutation(&a[0], &a[4]));
}

//&a[0] 해당 객체의 주소를 참조함 포인터, 포인터개념은 나중에 다루겠음

// 39. int형 a배열에 {1,2,3,4}의 원소를 집어넣는다 원소는 [0,1,2,3]의 인덱스를 가지게 됨
// 44. 이 상황에서 do-while loop 를 이용한다. do 블럭내에 범위기반 for문을 이용 배열 a의 원소를 전부 돌아 임시변수 i에 저장하여 값을 출력하고, 각각의 원소는 공백으로 표현해준다.
// 46. 이때 while문을 통해 검증이 진행됨 next_permutation 함수는 주어진 순열의 첫번째 주소와 마지막 주소를 참조함

/* next_permutation 동작원리


동작원리를 설명하자면 주어진 순열의 원소인 1 ~ 4 까지를 '오른쪽 부터' 오름차순으로 정렬된 숫자쌍을 찾는다. 이것은 현재 순열에서 더 큰 숫자를 찾기 위한 로직이고 이것을 교환기준이라고 함
코드의 경우 {1,2,3,4}의 원소를 가지는데, {1,2,3,4}의 경우 모든 원소가 오름차순으로 정의 되어있기 때문에 (3,4) 각각의 원소를 i, ii라 표현하고 첫 번째 원소보다 큰 원소인 4를 교환 기준 J로 삼는다.
원소 (3,4)중 i 번째인 3을 교환기준이자 ii번째 원소인 4와 자리를 교체한후 reverse 한다. (교환된 위치 이후의 숫자를 오름차순으로 정렬함.) 그렇게 되면 1,2,3,4 로 이미 나와있는 경우의 수가 있기 때문에 패스
결론적으로 1,2,4,3을 반환하게 됨

*/



